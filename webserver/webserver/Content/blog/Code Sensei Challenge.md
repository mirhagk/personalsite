Code Sensei Challenge
===

Source code is a poem, and programmers are poets. Source code is a story, and we are authors.

Those of us who love programming see it as an art form, and once you see it as an art form, you can start writing masterpieces.

There are tens of thousands of blogs, articles and videos to learn a framework or a language, and yet any programmer worth their salt will be happy to explain to you that "languages and frameworks don't matter, the skills are transferable and you can learn a new language or framework in a day if you're good enough".

Well now you understand the basics of programming, you know what a linked list is, and a hash table, how assembly works, and all the things that "every programmer should know". If you understand all these, what should you study next? Languages and frameworks can be picked up as needed, and while it's fun to play around with them, is there a better way to hone your skills?

Too often though we get trapped in the narrow minded world of a language or framework, and forget about programming in general. 

The code Sensei Challenge is a challenge where you give complete tasks that will help you become a better programmer, and go on your way to becoming a master of the art of programming. This is not for the faint of heart. If you feel you don't really understand the basics, this isn't the resource for you. But if you feel you got the basics down, you just want to go that extra step and become a guru of programming.

FAQ
---

###How long is this challenge?

However long it takes you. The challenges are all designed to teach you important concepts, and some of them may take you a while. There could be a challenge in here that may take you a month to do, but I can tell you that the time spent on it will be worth it. 

Code is just bytes
---

Save Often. Source Control. Regular Backups. These are the keys to a safe life. Without these you may find yourself yelling at the computer, and reflecting on your mistakes, and how you should've just pressed save, or the IDE should just auto-save.

This is very true, and it's not fun rewriting that function that you know works, and forgot to save on this machine, every code poet must understand that code is not permanent.

A good programmer should never be so attached to their code that they refuse to use a better implementation, or refuse to let go of their design practice. Just as code should adapt, so should the programmer.

Sometimes reusing old code isn't the answer, sometimes refactoring is too much work, and won't be effective. Sometimes you just need to start from scratch. In this challenge we will start from scratch.

Now before you think back to that function that someone else wrote that you hate with a passion, and want to get rid of, you must remember that that function had an author. That author may not have even been a bad programmer, and maybe that author looks with equal hatred at one of your own functions.

Evaluating your own code isn't an easy task however, and you may be inclined to think something is better simply because it was harder for you to do. Or maybe you fought with someone to get your code implemented, and now you think your solution must be the best.

Think back to your favorite piece of code. The one that is the most elegant solution to a problem, or accomplishes the most useful result. Ideally you want something that isn't too large or complicated, you want a function or class, not an entire project. Do the following:

1. Find all copies of the function in your end results
+ Find all repositories it's contained within.
+ Find all backups of your code that may contain it
+ Copy one copy onto a single USB stick
+ Give the USB stick to a trusted companion
+ Tell them not to give you it back unless you have admitted failure
+ Delete ALL extra copies of it (get rid of it from source control, and if possible the history, delete it from any backups). Leave it only in your projects that use it (ideally there should only be 1 or 2)
+ Create a new copy of the same project, but with that function or class completely removed. All traces, remove even any interfaces to the function if you think they are clever. Save that copy somewhere where you can get it in a week
+ Wait a week, forget about the function or class
+ Overwrite the original project with the copy. There should be no traces of this function anywhere now, not in your code, on your computer, or even in your brain.
+ Rewrite the function, trying not to remember how the old one worked
+ Once you've succeeded, ask your trusted friend to delete it from the USB stick
+ If you fail, then admit defeat and get the USB stick back from your friend and put it back in. Don't be crushed by this, this is a difficult task, simply try some other challenges and come back to this later.

After you've completed this challenge, you should've learned how to live without a piece of code. No longer will you check in code that's commented out. No longer will you resist code reviews on the basis that your solution is perceived as better.

Code is just bytes. It's not yours, and if yours isn't used, that's okay. As long as the sequence of bytes selected for use works, and is the best candidate, it doesn't matter if you wrote it, or your nemesis did.

There is no Universal Tool
---

If you take a look at any construction workers toolbox, it's rather large with many different tools. Yes Home Depot does sell tools that come with 147 different uses, but no respectable construction worker uses a single tool for their job.

As it is with programming. Everyone around you knows how much you love that awesome language or framework, and how you think it can do anything. But no matter how good that tool is, there are still better tools for certain jobs.

For this challenge you must select a project to work on. It could be a pet project you've always wanted to work on, or a previous project you'd have fun redoing.

There's no such thing as a wrong tool, just a difficult one
---

Your boss comes up to you and says he wants you to write a blog server in Fortran. You protest and say PHP already has libraries for that. Then he wants you to write a 3D video game using only PHP. You again protest and say C++ already has libraries for that.

Your protests should never be that it can't be done, it should be that it's simply much more difficult. You in fact can write a secure banking application in PHP, it's just more difficult. You can write a windows form application in haskell, it just requires more effort.

For this challenge you must select a project and choose what you think is the tool least fit for the job. Don't just choose a poor tool however, but rather something that may have it's own merits, just not for this. (Don't just choose brainfuck for any project).

Implement that project using that tool. This will teach you how to work with even poor tools to accomplish a task.



[qualitiesGoodProgrammer]: http://www.yacoset.com/Home/signs-that-you-re-a-good-programmer
[codelesscode]: http://thecodelesscode.com/contents